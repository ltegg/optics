# ################
# optics.py
# ################
#
# by Levi Tegg, 17 July 2017 (version 0.3)
#
# A Python 3.5 script to convert the *.epsilon file generated by WIEN2k's OPTIC
# into graphs and .csvs.
# 
# Parses *.epsilon files in the present working directory (pwd), into energy
# (eV), and eps1/eps2 for each direction in the *.epsilon file.
#
# From eps1/eps2, optical constants are calculated for each direction, then
# re-saved as a .csv (for analysis) and .dat (for use in MNPBEM14). Plots of 
# each optical constant are also saved.
#
# This is a re-write/port of the MATLAB script optical_constants_xx.m, written
# by me, which was based on prior scripts optical_constants.m, interpolation.m 
# and Chromaticity Template CIELAB 1976.xls, by Vicki Keast and others.

print('Starting optics.py...')


# %% -------
# INITIALISATION
# ----------
# %% Import some libraries
# Print the string, but don't linebreak at the end
print(' - Importing libraries.....................',end="") 

# Numpy to handle arrays and mathematics
import numpy as np
# Pyplot to make graphs
import matplotlib.pyplot as pl
# Sys to look at arguments passed to the function
import sys
# Glob to support UNIX style wildcards
import glob

print('Done!')


# %% Find the *.epsilon files
# Print the string, but don't linebreak at the end
print(' - Parsing arguments.......................') 

# Consider arguments to the script to be the names of *.epsilon files
epslist = sys.argv[1:]

# If there aren't any arguments passed
if len(epslist) == 0:
    # Search the pwd for all of the files ending in *.epsilon
    epslist=glob.glob('*.epsilon')
    print('      No arguments! Searching pwd for *epsilon file.')

# If there STILL aren't any *.epsilon files, print documentation
if len(epslist) == 0:
    print('      No *.epsilon files found in pwd!')
    print(' - Aborting!')
    print('    - In future, run this script in the same directory as *.epsilon files.')
    print('    - Alternatively, pass file names to the script via')
    print('       - $ optics.py case1.epsilon case2.epsilon ...')
    # Exit the script
    sys.exit(1)

# Print the number of files found
print('      ' + str(len(epslist)) + ' .epsilon file(s) found') 

# %% -------
# MAIN LOOP
# ----------

# Run the remainder of the script over every file in epslist
for epsfile in epslist:      
    
    
    # %% Find and parse data, sort into epsx, epsy, epsz
    # Print the string, but don't linebreak at the end
    print(' - File: ' + epsfile) 
   
    # Parse the .epsilon file found in the pwd
    data=np.loadtxt(epsfile,comments='#')
    
    # Assume first column of .epsilon file is energy in eV
    EeV=data[:,0]
    
    # Find out which columns are present, parse into initial epsx, epsy, epsz
    try: # try x-direction
        eps1x=data[:,1] # if 2nd column exists, set it to be eps1x
        eps2x=data[:,2] # if 3rd column exists, set it to be eps2x
        datax=1 # make variable saying data in x-direction exists
    except:
        datax=0 # else, make variable saying data in x-direction doesn't exist
        pass
    
    try: # try y-direction
        eps1y=data[:,3] # if 4th column exists, set it to be eps1y
        eps2y=data[:,4] # if 5th column exists, set it to be eps2y
        datay=1 # make variable saying data in y-direction exists
    except:
        datay=0 # else, make variable saying data in y-direction doesn't exist
        pass
    
    try: # try z-direction
        eps1z=data[:,5] # if 6th column exists, set it to be eps1z
        eps2z=data[:,6] # if 7th column exists, set it to be eps2z
        dataz=1 # make variable saying data in z-direction exists
    except:
        dataz=0 # else, make variable saying data in z-direction doesn't exist
        pass
    
    try: # try for an 8th column
        eps1z=data[:,7] # if 8th column is NOT imported....
    except:
        pass # ...do nothing
    else: # if 8th column IS imported, print the following
        print('')
        print('      More than 7 columns (1 energy + 6 epsilon) found.')
        print('      More than 3 dimensions not currently supported. Sorry!')
        print('      Aborting.')
        sys.exit(1) # ... just to terminate the script
    
        
    # %% Print the number of columns identified, and make assumptions
    if datax==1 and datay==0 and dataz==0:
        print('      3 columns (1 energy + 2 epsilon) found.')
        print('      Assuming epsx = epsy = epsz.')
    if datax==1 and datay==1 and dataz==0:
        print('      5 columns (1 energy + 4 epsilon) found.')
        print('      Assuming epsx = epsy =/= epsz.')
    if datax==1 and datay==1 and dataz==1:
        print('      7 columns (1 energy + 6 epsilon) found.')
        print('      Assuming epsx =/= epsy =/= epsz.')
    
    # Based on number of dimensions, make assumptions about undefined dimensions
    if datay==0 and dataz==0: # if data 1-dimensional, set epsx=epsy=epsz
        eps1y=eps1x # y-direction same as x-direction
        eps2y=eps2x
        eps1z=eps1x # z-direction same as x-direction
        eps2z=eps2x
    
    if datay==1 and dataz==0: # if data 2-dimensional, assume epsx=epsy=/=epsz
        eps1z=eps1y # rename the y-direction as the z-direction
        eps2z=eps2y
        eps1y=eps1x # make the y-direction equal to the x-direction
        eps2y=eps2x
    
    # %% -------
    # CALCULATE OPTICAL PROPERTIES
    # ----------
    # %% Calculating the optical constants
    # Print the string, but don't linebreak at the end
    print('    - Calculating optical constants...........',end="")
    
    # Calculate wavelength
    wl=1239.84/EeV
    
    # Calculate x-direction constants
    EELSx=eps2x/(eps1x**2+eps2x**2)
    nx=np.sqrt((np.sqrt(eps1x**2+eps2x**2)+eps1x)/2)
    kappax=np.sqrt((np.sqrt(eps1x**2+eps2x**2)-eps1x)/2)
    Rx=((nx-1)**2+kappax**2)/((nx+1)**2+kappax**2)
    
    # Calculate y-direction constants
    EELSy=eps2y/(eps1y**2+eps2y**2)
    ny=np.sqrt((np.sqrt(eps1y**2+eps2y**2)+eps1y)/2)
    kappay=np.sqrt((np.sqrt(eps1y**2+eps2y**2)-eps1y)/2)
    Ry=((ny-1)**2+kappay**2)/((ny+1)**2+kappay**2)
    
    # Calculate z-direction constants
    EELSz=eps2z/(eps1z**2+eps2z**2)
    nz=np.sqrt((np.sqrt(eps1z**2+eps2z**2)+eps1z)/2)
    kappaz=np.sqrt((np.sqrt(eps1z**2+eps2z**2)-eps1z)/2)
    Rz=((nz-1)**2+kappaz**2)/((nz+1)**2+kappaz**2)
    
    # Calculate space-averaged constants
    EELSxyz=(EELSx+EELSy+EELSz)/3
    Rxyz=(Rx+Ry+Rz)/3
    
    print('Done!')
    
    # %% -------
    # GRAPHING
    # ----------
    # %% Specify some parameters and dictionaries which affect plotting
    # Change some .rc parameters within Pyplot
    pl.rcParams.update({
                        'font.family':['Helvetica','Arial','Liberation Sans'], # use these fonts, in order of preference
                        'mathtext.default':'regular', # use regular text instead of latex mathtext
                        }) 
    
    # import matplotlib as mpl                 
    # sorted([f.name for f in mpl.font_manager.fontManager.ttflist])
        
    # The extension to use when saving images
    figext='.png'
    
    # The size of the figures produced
    figsize=[8,8]
    
    # The energy range over which to check data limits. 1-9 eV is [36,330] for default energy spacing in WIEN2k
    erange = [36,330]
    
    # A function which calculates the upper limit of the y-axis
    def upper(x,y,z):
        return np.ceil(1.1*max(max(x),max(y),max(z)))
    
    # A function which calculates the lower limit of the y-axis, based on whether it's metallic or insulating
    def lower(x,y,z):
        if min(min(x),min(y),min(z)) < 0: # if any of the eps1's go below zero
            return -8 # make the lower limit -8
        else:
            return 0 # otherwise, make it zero
    
    # Properties of axis labels
    axlabel = {'fontweight':'bold',
              'fontsize':14,
             }
    
    # Properties of legend
    # do this
    
    # Print the string, but don't linebreak at the end
    print('    - Plotting optical constants..............',end="")
    
    # %% Plot the dielectric function in the valence region
    # Make a figure with subplots
    fig, (ax1, ax2) = pl.subplots(2,1, sharex = True, figsize=figsize)
    
    # Remove the space between the plots
    fig.subplots_adjust(hspace=0)
    
    # Plot eps1 and eps2
    ax1.plot(EeV,eps1x,label=r'$ \varepsilon_1\ (x-dir) $') # always try to plot x-direction
    ax2.plot(EeV,eps2x,label=r'$ \varepsilon_2\ (x-dir) $')
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(EeV,eps1z,label=r'$ \varepsilon_1\ (z-dir) $') 
        ax2.plot(EeV,eps2z,label=r'$ \varepsilon_2\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(EeV,eps1y,label=r'$ \varepsilon_1\ (y-dir) $') 
        ax2.plot(EeV,eps2y,label=r'$ \varepsilon_2\ (y-dir) $')
        ax1.plot(EeV,eps1z,label=r'$ \varepsilon_1\ (z-dir) $')
        ax2.plot(EeV,eps2z,label=r'$ \varepsilon_2\ (z-dir) $')
    
    # Set axis limits and ticks
    ax1.set_xlim([0,8])
    ax2.set_xlim([0,8])
    ax1.set_ylim(lower(eps1x[erange[0]:erange[1]],eps1y[erange[0]:erange[1]],eps1z[erange[0]:erange[1]]), upper(eps1x[erange[0]:erange[1]],eps1y[erange[0]:erange[1]],eps1z[erange[0]:erange[1]]))
    ax2.set_ylim(0, upper(eps2x[erange[0]:erange[1]],eps2y[erange[0]:erange[1]],eps2z[erange[0]:erange[1]]))
    ax2.set_xticks(np.arange(0,9))
    
    # If eps1 goes below zero, add lines for eps1 =0, -1, -2, -8
    if  ax1.set_ylim()[0] == -8:
        # Add zero line
        ax1.axhline(y=0,color='k',ls='--')
        # Add -8, -2, and -1 ticks, and remove duplicate ticks
        ax1.yaxis.set_ticks(np.unique(np.append([-8,-2,-1],ax1.yaxis.get_majorticklocs())))
    
    # If the above if-statement changes the y-limits, reset them according to lower/upper
    ax1.set_ylim(lower(eps1x[erange[0]:erange[1]],eps1y[erange[0]:erange[1]],eps1z[erange[0]:erange[1]]), upper(eps1x[erange[0]:erange[1]],eps1y[erange[0]:erange[1]],eps1z[erange[0]:erange[1]]))
    
    # Remove the highest ticklabel from eps2, to avoid graphical issues
    ax2.yaxis.set_ticks(ax2.yaxis.get_majorticklocs()[0:-1])
    
    # Set labels and legends
    ax1.set_title('Valence Dielectric Function of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax2.set_xlabel('Energy (eV)',**axlabel)
    ax1.set_ylabel(r'$ \varepsilon_1 $',**axlabel)
    ax2.set_ylabel(r'$ \varepsilon_2 $',**axlabel)
    ax1.legend(loc='upper right')
    ax2.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    ax2.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_eps1eps2a'+figext)
    
    # %% Plot the dielectric function across the full energy range of the file
    # Make a figure with subplots
    fig, (ax1, ax2) = pl.subplots(2,1, sharex = True, figsize=figsize)
    
    # Remove the space between the plots
    fig.subplots_adjust(hspace=0)
    
    # Plot eps1 and eps2
    ax1.plot(EeV,eps1x,label=r'$ \varepsilon_1\ (x-dir) $') # always try to plot x-direction
    ax2.plot(EeV,eps2x,label=r'$ \varepsilon_2\ (x-dir) $')
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(EeV,eps1z,label=r'$ \varepsilon_1\ (z-dir) $') 
        ax2.plot(EeV,eps2z,label=r'$ \varepsilon_2\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(EeV,eps1y,label=r'$ \varepsilon_1\ (y-dir) $') 
        ax2.plot(EeV,eps2y,label=r'$ \varepsilon_2\ (y-dir) $')
        ax1.plot(EeV,eps1z,label=r'$ \varepsilon_1\ (z-dir) $')
        ax2.plot(EeV,eps2z,label=r'$ \varepsilon_2\ (z-dir) $')
    
    # Set axis limits and ticks
    ax1.set_xlim([0,max(EeV)])
    ax2.set_xlim([0,max(EeV)])
    ax1.set_ylim(lower(eps1x[36:],eps1y[36:],eps1z[36:]), upper(eps1x[36:],eps1y[36:],eps1z[36:]))
    ax2.set_ylim(0, upper(eps2x[36:],eps2y[36:],eps2z[36:]))
    
    # If eps1 goes below zero, add lines for eps1 =0, -1, -2, -8
    if  ax1.set_ylim()[0] == -8:
        # Add zero line
        ax1.axhline(y=0,color='k',ls='--')
        # Add -8, -2, and -1 ticks, and remove duplicate ticks
        ax1.yaxis.set_ticks(np.unique(np.append([-8,-2,-1],ax1.yaxis.get_majorticklocs())))
    
    # If the above if-statement changes the y-limits, reset them according to lower/upper
    ax1.set_ylim(lower(eps1x[36:],eps1y[36:],eps1z[36:]), upper(eps1x[36:],eps1y[36:],eps1z[36:]))
    
    # Remove the highest ticklabel from eps2, to avoid graphical issues
    ax2.yaxis.set_ticks(ax2.yaxis.get_majorticklocs()[0:-1])
    
    # Set labels and legends
    ax1.set_title('Full-Range Dielectric Function of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax2.set_xlabel('Energy (eV)',**axlabel)
    ax1.set_ylabel(r'$ \varepsilon_1 $',**axlabel)
    ax2.set_ylabel(r'$ \varepsilon_2 $',**axlabel)
    ax1.legend(loc='upper right')
    ax2.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    ax2.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_eps1eps2b'+figext)
    
    # %% Plot the EELS in the valence region
    # Make a figure
    fig, ax1 = pl.subplots(1,1, sharex = True, figsize=figsize)
    
    # Plot the EELS
    ax1.plot(EeV,EELSx,label=r'$ EELS\ (x-dir) $') # always try to plot x-direction
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(EeV,EELSz,label=r'$ EELS\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(EeV,EELSy,label=r'$ EELS\ (y-dir) $')
        ax1.plot(EeV,EELSz,label=r'$ EELS\ (z-dir) $')
    ax1.plot(EeV,EELSxyz,label=r'$ EELS\ (xyz-avg) $',c='k') # plot average EELSxyz in black
    
    # Set axis limits and ticks
    ax1.set_xlim([0,8])
    ax1.set_xticks(np.arange(0,9))
    ax1.set_ylim(0, upper(EELSx[erange[0]:erange[1]],EELSy[erange[0]:erange[1]],EELSz[erange[0]:erange[1]]))
    
    # Set labels and legends
    ax1.set_title('Valence EELS of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax1.set_xlabel('Energy (eV)',**axlabel)
    ax1.set_ylabel(r'$ EELS\ (Im(\!-\!1/\varepsilon)) $',**axlabel)
    ax1.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_EELSa'+figext)
    
    
    # %% Plot the EELS across the full energy range of the file
    # Make a figure
    fig, ax1 = pl.subplots(1,1, sharex = True, figsize=figsize)
    
    # Plot the EELS
    ax1.plot(EeV,EELSx,label=r'$ EELS\ (x-dir) $') # always try to plot x-direction
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(EeV,EELSz,label=r'$ EELS\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(EeV,EELSy,label=r'$ EELS\ (y-dir) $')
        ax1.plot(EeV,EELSz,label=r'$ EELS\ (z-dir) $')
    ax1.plot(EeV,EELSxyz,label=r'$ EELS\ (xyz-avg) $',c='k') # plot average EELSxyz in black
    
    # Set axis limits and ticks
    ax1.set_xlim([0,max(EeV)])
    
    # Set labels and legends
    ax1.set_title('Full-range EELS of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax1.set_xlabel('Energy (eV)',**axlabel)
    ax1.set_ylabel(r'$ EELS\ (Im(\!-\!1/\varepsilon)) $',**axlabel)
    ax1.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_EELSb'+figext)
    
    
    # %% Plot the complex valued refractive index
    # Make a figure with subplots
    fig, (ax1, ax2) = pl.subplots(2,1, sharex = True, figsize=figsize)
    
    # Remove the space between the plots
    fig.subplots_adjust(hspace=0)
    
    # Plot eps1 and eps2
    ax1.plot(wl,nx,label=r'$ n\ (x-dir) $') # always try to plot x-direction
    ax2.plot(wl,kappax,label=r'$ \kappa\ (x-dir) $')
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(wl,nz,label=r'$ n\ (z-dir) $') 
        ax2.plot(wl,kappaz,label=r'$ \kappa\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(wl,ny,label=r'$ n\ (y-dir) $') 
        ax2.plot(wl,kappay,label=r'$ \kappa\ (y-dir) $')
        ax1.plot(wl,nz,label=r'$ n\ (z-dir) $')
        ax2.plot(wl,kappaz,label=r'$ \kappa\ (z-dir) $')
    
    # Set axis limits and ticks
    ax1.set_xlim([200,2000])
    ax2.set_xlim([200,2000])
    ax1.set_ylim(0, upper(nx[erange[0]:erange[1]],ny[erange[0]:erange[1]],nz[erange[0]:erange[1]]))
    ax2.set_ylim(0, upper(kappax[erange[0]:erange[1]],kappay[erange[0]:erange[1]],kappaz[erange[0]:erange[1]]))
    ax2.yaxis.set_ticks(ax2.yaxis.get_majorticklocs()[0:-1])
    
    
    # Insert vertical lines representing the visible range
    ax1.axvline(x=380,color='k',ls='--')
    ax1.axvline(x=780,color='k',ls='--')
    ax2.axvline(x=380,color='k',ls='--')
    ax2.axvline(x=780,color='k',ls='--')
    
    
    # Set labels and legends
    ax1.set_title('Complex refractive index of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax2.set_xlabel('Wavelength (nm)',**axlabel)
    ax1.set_ylabel(r'$ n $',**axlabel)
    ax2.set_ylabel(r'$ \kappa $',**axlabel)
    ax1.legend(loc='upper right')
    ax2.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    ax2.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_n,k'+figext)
    
    
    # %% Plot the reflectivity
    # Make a figure
    fig, ax1 = pl.subplots(1,1, sharex = True, figsize=figsize)
    
    # Plot the EELS
    ax1.plot(wl,Rx,label=r'$ R\ (x-dir) $') # always try to plot x-direction
    if datay==1 and dataz==0: # if 2D case, also plot z-direction
        ax1.plot(wl,Rz,label=r'$ R\ (z-dir) $')
    if datay==1 and dataz==1: # if 3D case, also plot y-direction and z-direction
        ax1.plot(wl,Ry,label=r'$ R\ (y-dir) $')
        ax1.plot(wl,Rz,label=r'$ R\ (z-dir) $')
    ax1.plot(wl,Rxyz,label=r'$ R\ (xyz-avg) $',c='k') # plot average EELSxyz in black
    
    # Set axis limits and ticks
    ax1.set_xlim([200,2000])
    ax1.set_ylim([0,1])
    #ax1.set_xticks(np.linspace(200,2000,num=19))
    ax1.set_yticks(np.linspace(0,1.0,num=11))
    
    # Insert vertical lines representing the visible range
    ax1.axvline(x=380,color='k',ls='--')
    ax1.axvline(x=780,color='k',ls='--')
    
    # Set labels and legends
    ax1.set_title('Reflectivity of '+epsfile[0:len(epsfile)-8]) # gets file basename
    ax1.set_xlabel('Wavelength (nm)',**axlabel)
    ax1.set_ylabel('Reflectivity',**axlabel)
    ax1.legend(loc='upper right')
    
    # Turn gridlines on
    ax1.grid()
    
    # Save the figure
    pl.savefig(epsfile[0:len(epsfile)-8]+'_R'+figext)
    
    
    print('Done!')
    
    
    # %% -------
    # PRINT TO DISC
    # ----------
    # %% Save optical constants to .csv
    # Print the string, but don't linebreak at the end
    print('    - Saving optical constants to *.csv.......',end="")
    
    # Set up the array to be saved, depending on the number of dimensions
    if datay==0 and dataz==0:
        # to a title array, append a stack of the data variables. csv becomes an array of <U32
        csv=np.append(np.array([['E(eV)','Wavelength(nm)','eps1x','eps2x','EELSx','nx','kappax','Rx']]),np.stack(([EeV,wl,eps1x,eps2x,EELSx,nx,kappax,Rx]),axis=1),axis=0)
    
    if datay==1 and dataz==0:
        # to a title array, append a stack of the data variables. csv becomes an array of <U32
        csv=np.append(np.array([['E(eV)','Wavelength(nm)','eps1x','eps2x','eps1z','eps2z','EELSx','EELSz','nx','kappax','nz','kappaz','Rx','Rz']]),np.stack(([EeV,wl,eps1x,eps2x,eps1z,eps2z,EELSx,EELSz,nx,kappax,nz,kappaz,Rx,Rz]),axis=1),axis=0)
    
    if datay==1 and dataz==1:
        csv=np.append(np.array([['E(eV)','Wavelength(nm)','eps1x','eps2x','eps1y','eps2y','eps1z','eps2z','EELSx','EELSy','EELSz','nx','kappax','ny','kappay','nz','kappaz','Rx','Ry','Rz']]),np.stack(([EeV,wl,eps1x,eps2x,eps1y,eps2y,eps1z,eps2z,EELSx,EELSy,EELSz,nx,kappax,ny,kappay,nz,kappaz,Rx,Ry,Rz]),axis=1),axis=0)
    
    # Commit the array to disc
    np.savetxt(epsfile[0:len(epsfile)-8]+'_optics.csv',csv,fmt='%s',delimiter=',')
    
    print('Done!')
    
    
    # %% Save EeV, n, k to .dat (for MNPBEM14)
    # Print the string, but don't linebreak at the end
    print('    - Saving E(eV), nx and kx to *.dat........',end="")
    
    # Set up the array. Use nxyz and kxyz.
    dat=np.append(np.array([['% (x+y+z)/3 refractive index data from '+epsfile[0:len(epsfile)-8],' ',' '],['% E(eV) n(xyz) k(xyz)',' ',' ']]),np.stack((EeV,((nx+ny+nz)/3),((kappax+kappay+kappaz)/3)),axis=1),axis=0)
    
    # Commit the array to disc
    np.savetxt(epsfile[0:len(epsfile)-8]+'.dat',dat,fmt='%s',delimiter=' ')
    
    print('Done!')
    
    # %% -------
    # CALCULATE COLOUR
    # ----------
    # Print the string, but don't linebreak at the end
    print('    - Calculating material colour.............',end="")
    
    
    # %% Define the colour calculation function
    # This has been assembled mostly from EasyRGB.com
    def apparentcolour(R):
        # Interpolate input reflectivity over an evenly spaced wavelength grid
        wli=np.linspace(380,780,num=81) # wavelength range used to calculate colour
        # Flip both wl and R to ensure wl is always increasing. Interpolate R.
        Ri=np.interp(wli,list(reversed(wl)),list(reversed(R))) # Rxyz interpolated
    
        # Define the colour matching functions xbar, ybar, zbar
        cxbar = np.array([0.0014,0.0022,0.0042,0.0076,0.0143,0.0232,0.04350,0.0776,0.1344,0.2148,0.2839,0.3285,0.3483,0.3481,0.3362,0.3187,0.2908,0.2511,0.1954,0.1421,0.0956,0.0580,0.0320,0.0147,0.00490,0.00240,0.00930,0.0291,0.0633,0.1096,0.1655,0.2257,0.2904,0.3597,0.4334,0.5121,0.594500,0.67840,0.76210,0.84250,0.91630,0.97860,1.0263,1.0567,1.0622,1.0456,1.0026,0.93840,0.85440,0.75140,0.64240,0.54190,0.44790,0.36080,0.2835,0.2187,0.1649,0.1212,0.08740,0.06360,0.04680,0.03290,0.02270,0.01580,0.01140,0.008100,0.005800,0.004100,0.002900,0.002,0.001400,0.001,0.0007,0.0005,0.0003,0.0002,0.0002,0.0001,0.0001,0.0001,0,])
        cybar = np.array([0,0.0001,0.0001,0.0002,0.0004,0.0006,0.001200,0.002200,0.004,0.007300,0.01160,0.01680,0.02300,0.02980,0.03800,0.04800,0.06,0.07390,0.09100,0.1126,0.1390,0.1693,0.2080,0.2586,0.3230,0.4073,0.5030,0.6082,0.7100,0.7932,0.8620,0.9149,0.9540,0.9803,0.9950,1,0.9950,0.9786,0.9520,0.9154,0.8700,0.8163,0.7570,0.6949,0.6310,0.5668,0.5030,0.4412,0.3810,0.3210,0.2650,0.2170,0.1750,0.1382,0.1070,0.08160,0.06100,0.04460,0.03200,0.02320,0.01700,0.01190,0.008200,0.005700,0.004100,0.002900,0.002100,0.001500,0.001,0.0007,0.0005,0.0004,0.0002,0.0002,0.0001,0.0001,0.0001,0,0,0,0,])
        czbar = np.array([0.006500,0.01050,0.02010,0.03620,0.06790,0.1102,0.2074,0.3713,0.6456,1.0391,1.3856,1.623,1.7471,1.7826,1.7721,1.7441,1.6692,1.5281,1.2876,1.0419,0.8130,0.6162,0.4652,0.3533,0.2720,0.2123,0.1582,0.1117,0.07820,0.05730,0.04220,0.02980,0.02030,0.01340,0.008700,0.005700,0.003900,0.002700,0.002100,0.001800,0.001700,0.001400,0.001100,0.001,0.0008,0.0006,0.0003,0.0002,0.0002,0.0001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,])
        
        # Define variables Qx, Qy, Qz 
        # Each is Qx='X'/'Xn'=sum(xbar*Ri*wli*wl*step*constant)/sum(xbar*wli*wl*step*constant)
        cQx = np.sum(cxbar*Ri*wli*5*0.935843)/np.sum(cxbar*wli*5*0.935843)
        cQy = np.sum(cybar*Ri*wli*5*0.935843)/np.sum(cybar*wli*5*0.935843)
        cQz = np.sum(czbar*Ri*wli*5*0.935843)/np.sum(czbar*wli*5*0.935843)
        
        # Define the variables fQx, fQy, fQz
        if cQx > (6/29)**3:
            cfQx = cQx**(1/3)
        else:
            cfQx = (cQx*(841/108)+4/29)
        if cQy > (6/29)**3: # I don't know what this is
            cfQy = cQy**(1/3)
        else:
            cfQy = (cQy*(841/108)+4/29)
        if cQz > (6/29)**3: # I don't know what this is
            cfQz = cQz**(1/3)
        else:
            cfQz = (cQz*(841/108)+4/29)
        
        # Define the CIE L, a and b co-ordinates
        cL=(116*cfQy)-16
        ca=500*(cfQx-cfQy)
        cb=200*(cfQy-cfQz)
        
        # Convert Lab co-ordinates into XYZ co-ordinates. Ref EasyRGB.com
        cY=(cL+16)/116
        cX=(ca/500)+cY
        cZ=cY-(cb/200)
        
        # Fix range of cY, cX, cZ
        if cY**3 > 0.008856:
            cY=cY**3
        else:
            cY=((cY-16)/116)/7.787
        if cX**3>0.008856:
            cX=cX**3
        else:
            cX=((cX-16)/116)/7.787
        if cZ**3>0.008856:
            cZ=cZ**3
        else:
            cZ=((cZ-16)/116)/7.787
        
        # Mulyiple cX,cY,cZ by reference light (2deg view angle, D65 lamp)
        cX=cX*95.047
        cY=cY*100
        cZ=cZ*108.883
        
        # Convert XYZ co-ordinates into RGB triplet.
        cR=(cX*0.032406)+(cY*-0.015372)+(cZ*-0.004986)
        cG=(cX*-0.009689)+(cY*0.018758)+(cZ*0.000415)
        cB=(cX*0.000557)+(cY*-0.002040)+(cZ*0.010570)
        
        if cR>0.0031308:
            cR=1.055*(cR**(1/2.4))-0.055
        else:
            cR=12.92*cR
        if cG>0.0031308:
            cG=1.055*(cG**(1/2.4))-0.055
        else:
            cG=12.92*cG
        if cB>0.0031308:
            cB=1.055*(cB**(1/2.4))-0.055
        else:
            cB=12.92*cB
        
        # Clip cR/cG/cB to 0..1
        [cR,cG,cB]=np.clip(np.array([cR,cG,cB]),0,1) # clip cR/cG/cB to 0..1
        # Make RGB co-ordinates positive integers, which are accessible outside the function
        apparentcolour.cR=np.abs(np.round(cR*255,0))
        apparentcolour.cG=np.abs(np.round(cG*255,0))
        apparentcolour.cB=np.abs(np.round(cB*255,0))
        
    
    # %% Set up structures to loop over the four reflectivities
    # Make an array of all four reflectivities
    Rtotal = np.array([Rxyz,Rx,Ry,Rz])
    
    # Make an array to which we will append the RGB triplets from each direction
    RGB = np.array([[0,0,0]])
    
    # Loop over the four reflectivities, indexed by i
    for i in [0,1,2,3]: 
        # Calculate the apparent colour of each
        apparentcolour(Rtotal[i,:]) 
        # Append the RGB triplet obtained to the end of the RGB array
        RGB = np.append(RGB,[[apparentcolour.cR,apparentcolour.cG,apparentcolour.cB]],axis=0)
    
    # Remove the first line of RGB array
    RGB = RGB[1:,:]
    
    print('Done!')
    
    
    # %% Plot the apparent colour, in the xyz, x, y, and z directions
    # Print the string, but don't linebreak at the end
    print('    - Plotting apparent colour................',end="")
    
    # Make a figure
    fig, ax1 = pl.subplots(1,1, sharex = True, figsize=[6,5])
    
    # Make rectangles for the xyz, x, y, and z colours
    ax1.axhspan(0,1,0,0.5,color=[RGB[0,0]/255,RGB[0,1]/255,RGB[0,2]/255],fc=[RGB[0,0]/255,RGB[0,1]/255,RGB[0,2]/255])
    ax1.axhspan(2/3,3/3,0.5,1,color=[RGB[1,0]/255,RGB[1,1]/255,RGB[1,2]/255],fc=[RGB[1,0]/255,RGB[1,1]/255,RGB[1,2]/255])
    ax1.axhspan(1/3,2/3,0.5,1,color=[RGB[2,0]/255,RGB[2,1]/255,RGB[2,2]/255],fc=[RGB[2,0]/255,RGB[2,1]/255,RGB[2,2]/255])
    ax1.axhspan(0/3,1/3,0.5,1,color=[RGB[3,0]/255,RGB[3,1]/255,RGB[3,2]/255],fc=[RGB[3,0]/255,RGB[3,1]/255,RGB[3,2]/255])
    
    # Make inserts for the text labels
    ax1.axhspan(0.93,1.0,0.0,0.4,fc='k')
    ax1.axhspan(0.93,1.0,0.5,0.85,fc='k')
    ax1.axhspan((2/3)-0.07,2/3.0,0.5,0.85,fc='k')
    ax1.axhspan((1/3)-0.07,1/3.0,0.5,0.85,fc='k')
    
    # Print the RGB triplets in the various cells of the figure
    ax1.text(0.02,0.95,'xyz-dir: {0:=03.0f} {1:=03.0f} {2:=03.0f}'.format(RGB[0,0],RGB[0,1],RGB[0,2]),color='w')
    ax1.text(0.52,0.95,'x-dir: {0:=03.0f} {1:=03.0f} {2:=03.0f}'.format(RGB[1,0],RGB[1,1],RGB[1,2]),color='w')
    ax1.text(0.52,(2/3)-0.05,'y-dir: {0:=03.0f} {1:=03.0f} {2:=03.0f}'.format(RGB[2,0],RGB[2,1],RGB[2,2]),color='w')
    ax1.text(0.52,(1/3)-0.05,'z-dir: {0:=03.0f} {1:=03.0f} {2:=03.0f}'.format(RGB[3,0],RGB[3,1],RGB[3,2]),color='w')
    
    # Turn off the axis labels
    ax1.axis('off')
    
    # Title
    ax1.set_title('Approximate sRGB of ' + epsfile[0:len(epsfile)-8])
    
    pl.savefig(epsfile[0:len(epsfile)-8]+'_colour'+figext)
    
    
    print('Done!')
    
    
    # %% File done!
    print(' - File finished!')
    
# %% All done!
print('All finished!')